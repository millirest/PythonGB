# Напишите функцию print_operation_table(operation, num_rows, num_columns), 
# которая принимает в качестве аргумента функцию, вычисляющую элемент по номеру строки и столбца. 
# По умолчанию номер столбца и строки = 9.

# Аргументы num_rows и num_columns указывают число строк и столбцов таблицы, которые должны быть распечатаны.
# Нумерация строк и столбцов идет с единицы (подумайте, почему не с нуля).
# Если строк меньше двух, выдайте текст
# ОШИБКА! Размерности таблицы должны быть больше 2!.

# Примечание: бинарной операцией называется любая операция, у которой ровно два аргумента, 
# как, например, у операции умножения.

# Между элементами должен быть 1 пробел, в конце строки пробел не нужен.
# Пример

# На входе:
# print_operation_table(lambda x, y: x * y, 3, 3)

# На выходе:

# 1 2 3
# 2 4 6 
# 3 6 9

#Решение

# def print_operation_table(operation, num_rows, num_columns):
#     if num_rows < 2 or num_columns <2 : print ("ОШИБКА! Размерности таблицы должны быть больше 2!")
#     else:
#         for i in range(1,num_rows+1):
#             list1 = list()  
#             for j in range(1,num_columns+1):
#                 list1.append(operation(i,j))
#             print(*list1, sep=" ")

# print_operation_table(lambda x, y: x + y, 5, 5)


#Задача 2
# Винни-Пух попросил Вас посмотреть, есть ли в его стихах ритм. 
# Поскольку разобраться в его кричалках не настолько просто, насколько легко он их придумывает, 
# Вам стоит написать программу.

# Винни-Пух считает, что ритм есть, если число слогов (т.е. число гласных букв) 
# в каждой фразе стихотворения одинаковое.
# Фраза может состоять из одного слова, если во фразе несколько слов, то они разделяются дефисами.
# Фразы отделяются друг от друга пробелами.

# Стихотворение  Винни-Пух передаст вам автоматически в переменную stroka в виде строки. 
# В ответе напишите Парам пам-пам, если с ритмом все в порядке и Пам парам, если с ритмом все не в порядке.
# Если фраза только одна, то ритм определить не получится и необходимо вывести: 
# Количество фраз должно быть больше одной!.

# Пример
# На входе:
# stroka = 'пара-ра-рам рам-пам-папам па-ра-па-дам'

# На выходе:
# Парам пам-пам

#stroka = 'пара-ра-рам рам-пам-папам па-ра-па-дам'

# stroka = "по-русски говорят"


# # Моё решение

# def same_by(object):
#     result = True
#     #list1 = [x for x in object]
#     for i in range(len(object)-1):
#         if object[i] != object[i+1]:
#             result = False
#     return result

# def Presence_Ritm(text):
#     Ritm_list = list()
#     slova = list(text.split(" "))
#     if len(slova)<2: return print("Количество фраз должно быть больше одной!")
#     for i in slova:
#         s = 0
#         for j in i:
#             if j in 'уеыаоэяи':
#                 s += 1
#         Ritm_list.append(s)
#     if same_by(Ritm_list): print("Парам пам-пам")
#     else:
#         print("Пам парам")

# Presence_Ritm(stroka)

# ###### Идеальное решение

# vowels = ['а', 'е', 'ё', 'и', 'й', 'о', 'у', 'ы', 'э', 'ю', 'я']
# phrases = stroka.split()
# if len(phrases) < 2:
#  print('Количество фраз должно быть больше одной!')
# else:
#  countVowels = []

#  for i in phrases:
#   countVowels.append(len([x for x in i if x.lower() in vowels]))

#  if countVowels.count(countVowels[0]) == len(countVowels):
#   print('Парам пам-пам')
#  else:
#   print('Пам парам')


# Задание 1. Новые списки

# Даны три списка:

#   1. floats: List[float] = [12.3554, 4.02, 5.777, 2.12, 3.13, 4.44, 11.0001]
#   2. names: List[str] = ["Vanes", "Alen", "Jana", "William", "Richards", "Joy"]
#   3. numbers: List[int] = [22, 33, 10, 6894, 11, 2, 1]

# Напишите код, который создаёт три новых списка. Вот их содержимое:

#   1. Каждое число из списка floats возводится в третью степень и округляется
#      до трёх знаков после запятой.
#   2. Из списка names берутся только имена минимум из пяти букв.
#   3. Из списка numbers берётся произведение всех чисел.

# Подсказка № 1
# Используйте функцию map() для применения одной и той же операции ко всем
# элементам списка. Для возведения числа в третью степень и округления его до трех
# знаков после запятой используйте лямбда-функцию внутри map().

# Подсказка № 2
# Функция filter() позволяет отфильтровать элементы списка на основе заданного
# условия. В данном случае используйте её для выбора имен, состоящих из пяти и
# более букв. Убедитесь, что лямбда-функция правильно проверяет длину строки.

# Подсказка № 3
# Для нахождения произведения всех чисел в списке используйте функцию reduce().
# Эта функция последовательно применяет операцию (в данном случае умножение) ко
# всем элементам списка. Убедитесь, что вы импортировали reduce из модуля
# functools.

#Моё решение

# from functools import reduce

# floats = [12.3554, 4.02, 5.777, 2.12, 3.13, 4.44, 11.0001]
# names = ["Vanes", "Alen", "Jana", "William", "Richards", "Joy"]
# numbers = [22, 33, 10, 6894, 11, 2, 1]

# NewFloats = list(map(lambda x: round(x**3,3) ,floats))
# print(NewFloats)
# NewNames = list(filter(lambda name: len(name)>5, names))
# print(NewNames)
# newNambers= reduce(lambda x, y: x*y, numbers)
# print(newNambers)


# Эталонное решение:

# from functools import reduce

# # Исходные списки
# floats = [12.3554, 4.02, 5.777, 2.12, 3.13, 4.44, 11.0001]
# names = ["Vanes", "Alen", "Jana", "William", "Richards", "Joy"]
# numbers = [22, 33, 10, 6894, 11, 2, 1]

# # Применяем функцию map для возведения в третью степень и округления до трех знаков после запятой
# map_result = list(map(lambda x: round(x ** 3, 3), floats))

# # Применяем функцию filter для выбора имен из пяти и более букв
# filter_result = list(filter(lambda name: len(name) >= 5, names))

# # Применяем функцию reduce для нахождения произведения всех чисел в списке
# reduce_result = reduce(lambda num1, num2: num1 * num2, numbers)

# # # Вывод результатов

# print(map_result)
# print(filter_result)
# print(reduce_result)



# Задача 2. Zip
# Даны список букв (letters) и список цифр (numbers). Каждый список состоит из N
# элементов. Создайте кортежи из пар элементов списков и запишите их в список
# results. Не используйте функцию zip. Решите задачу в одну строку (не считая print(results)).

# Примеры списков:
# letters: List[str] = ['a', 'b', 'c', 'd', 'e']
# numbers: List[int] = [1, 2, 3, 4, 5, 6, 7, 8]

# Результат работы программы:
# [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]

# Подсказка № 1
# Перед созданием кортежей из пар элементов убедитесь, что оба списка имеют
# одинаковую длину. Если это не так, то результат может быть непредсказуемым. Также
# проверьте типы данных в списках. Неправильная длина списков может привести к
# недопониманию в том, как будут сформированы кортежи, и ошибка будет в исходных
# данных.

# Подсказка № 2
# Используйте функцию map вместе с лямбда-функцией, чтобы создать список кортежей.
# В лямбда-функции укажите, что каждый элемент из первого списка должен быть
# объединен с элементом из второго списка.

# Подсказка № 3
# Внутри лямбда-функции используйте параметры x и y для представления элементов
# из первого и второго списков соответственно. Создайте кортеж (x, y).

# Подсказка № 4
# Приведите результат работы map к списку с помощью функции list(). Это
# преобразует объект map в список, содержащий кортежи.

#Моё решение



# Эталонное решение:

from typing import List, Tuple

# Исходные списки
strings = ['a', 'b', 'c', 'd', 'e']
numbers = [1, 2, 3, 4, 5, 6, 7, 8]

# Создание списка кортежей, состоящих из пар элементов из обоих списков
results: List[Tuple[str, int]] = list(map(lambda x, y: (x, y), strings, numbers))

# Вывод результатов
print(results)



# Задача 3. Палиндром

# Используя модуль collections, реализуйте функцию can_be_poly, которая
# принимает на вход строку и проверяет, можно ли получить из неё палиндром.

# Пример кода:
# print(can_be_poly('abcba'))
# print(can_be_poly('abbbc'))

# Результат:
# True
# False

# Подсказка № 1
# Перед реализацией функции can_be_poly, импортируйте модуль Counter из пакета
# collections. Он понадобится для подсчета частоты вхождения каждого символа в
# строку. Counter поможет создать частотный словарь, который упрощает подсчет и
# анализ символов в строке.

# Подсказка № 2
# Для проверки, можно ли получить палиндром, вычислите количество символов с
# нечетной частотой. Используйте функцию filter и лямбда-функцию для фильтрации
# значений частот, оставляя только те, которые имеют нечетное количество вхождений.

# Подсказка № 3
# Подсчитайте количество элементов в отфильтрованном списке и проверьте, что их
# количество меньше 2. Это условие указывает на то, что строка может быть
# переставлена в палиндром.

# Эталонное решение:

# from collections import Counter
# def can_be_poly(val: str) -> bool:

# # Создаем счетчик частот символов в строке
# char_counts = Counter(val)

# # Проверяем количество символов с нечетным количеством вхождений
# odd_count = len(list(filter(lambda x: x % 2,
# char_counts.values())))

# # Условие для проверки возможности формирования палиндрома
# return odd_count < 2
# print(can_be_poly('eerru')) # Ожидаемый результат: True
# print(can_be_poly('abbcba')) # Ожидаемый результат: True
# print(can_be_poly('abbbc')) # Ожидаемый результат: False



# Задача 4. Уникальный шифр

# Напишите функцию, которая принимает строку и возвращает количество
# уникальных символов в строке. Используйте для выполнения задачи
# lambda-функции и map и/или filter.

# Сделайте так, чтобы алгоритм НЕ был регистрозависим: буквы разного
# регистра должны считаться одинаковыми.

# Пример:
# message = "Today is a beautiful day! The sun is shining and the birds are singing."
# unique_count = count_unique_characters(message)
# print("Количество уникальных символов в строке:", unique_count)
# Вывод: количество уникальных символов в строке — 5.

# Подсказка № 1
# Перед началом работы убедитесь, что строка преобразована в нижний регистр. Это
# нужно для того, чтобы подсчет символов был регистронезависимым. Преобразование
# строки к нижнему регистру помогает избежать различий между символами разного
# регистра, так как a и A будут считаться одним и тем же символом.

# Подсказка № 2
# Используйте filter для выбора уникальных символов. Примените к каждому символу
# лямбда-функцию, которая проверяет, встречается ли символ в строке ровно один раз.
# Функция filter отфильтрует символы, у которых количество вхождений в строке
# ровно 1, благодаря проверке внутри лямбда-функции.

# Подсказка № 3
# Для проверки количества вхождений символа используйте метод count. Он
# возвращает количество вхождений подстроки в строке. Метод count позволяет узнать,
# сколько раз символ встречается в строке, что необходимо для проверки уникальности
# символов.

# Подсказка № 4
# Преобразуйте результат фильтрации в список с помощью list(). Это сделает
# обработку отфильтрованных символов удобнее. Преобразование результата filter в
# список позволяет работать с ним как с обычным списком и получить доступ к его
# длине.

# Подсказка № 5
# Возвращайте длину списка уникальных символов с помощью len(). Это даст
# количество уникальных символов в строке.

# Эталонное решение:
# def count_unique_characters(string):

# # Приводим строку к нижнему регистру, чтобы сделать подсчет регистронезависимым
# lower_string = string.lower()

# # Используем filter для выбора символов, которые встречаются в строке ровно один раз
# unique_chars = list(filter(lambda c:
# lower_string.count(c.lower()) == 1, lower_string))

# # Выводим уникальные символы (по желанию, можно удалить эту строку)
# print(unique_chars)

# # Возвращаем количество уникальных символов
# return len(unique_chars)

# # Пример использования:
# message = "Today is a beautiful day! The sun is shining and the birds are singing."
# unique_count = count_unique_characters(message)
# print("Количество уникальных символов в строке:", unique_count)